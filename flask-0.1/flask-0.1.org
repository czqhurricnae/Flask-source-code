# -*- eval: (setq org-download-image-dir (concat default-directory "/screenshotImg")); -*-

#+BEGIN_SRC python :results valuse list :exports both
# -*- coding: utf-8 -*-
"""
    flask
    ~~~~~

    A microframework based on Werkzeug.  It's extensively documented
    and follows best practice patterns.

    :copyright: (c) 2010 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
"""
import os
import sys
import pkg_resources
from threading import local
from jinja2 import Environment, PackageLoader
from werkzeug import Request, Response, LocalStack, LocalProxy
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException, InternalServerError
from werkzeug.contrib.securecookie import SecureCookie

# try to import the json helpers
try:
    from simplejson import loads as load_json, dumps as dump_json
except ImportError:
    try:
        from json import loads as load_json, dumps as dump_json
    except ImportError:
        pass

# utilities we import from Werkzeug and Jinja2 that are unused
# in the module but are exported as public interface.
from werkzeug import abort, redirect, secure_filename, cached_property, \
    html, import_string, generate_password_hash, check_password_hash
from jinja2 import Markup, escape


class FlaskRequest(Request):
    """The request object used by default in flask.  Remembers the
    matched endpoint and view arguments.
    """

    def __init__(self, environ):
        Request.__init__(self, environ)
        self.endpoint = None
        self.view_args = None


class FlaskResponse(Response):
    """The response object that is used by default in flask.  Works like the
    response object from Werkzeug but is set to have a HTML mimetype by
    default.
    """
    default_mimetype = 'text/html'


class _RequestGlobals(object):
    pass


class _RequestContext(object):
    """The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None


def url_for(endpoint, **values):
    """Generates a URL to the given endpoint with the method provided.

    :param endpoint: the endpoint of the URL (name of the function)
    :param values: the variable arguments of the URL rule
    """
    return _request_ctx_stack.top.url_adapter.build(endpoint, values)


def jsonified(**values):
    """Returns a json response"""
    return current_app.response_class(dump_json(values),
                                      mimetype='application/json')


def flash(message):
    """Flashes a message to the next request.  In order to remove the
    flashed message from the session and to display it to the user,
    the template has to call :func:`get_flashed_messages`.
    """
    session['_flashes'] = (session.get('_flashes', [])) + [message]


def get_flashed_messages():
    """Pulls all flashed messages from the session and returns them.
    Further calls in the same request to the function will return
    the same messages.
    """
    flashes = _request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = \
            session.pop('_flashes', [])
    return flashes


def render_template(template_name, **context):
    """Renders a template from the template folder with the given
    context.
    """
    return current_app.jinja_env.get_template(template_name).render(context)


def render_template_string(source, **context):
    """Renders a template from the given template source string
    with the given context.
    """
    return current_app.jinja_env.from_string(source).render(context)


class Flask(object):
    """The flask object implements a WSGI application and acts as the central
    object.  It is passed the name of the module or package of the application
    and optionally a configuration.  When it's created it sets up the
    template engine and provides ways to register view functions.
    """

    #: the class that is used for request objects
    request_class = FlaskRequest

    #: the class that is used for response objects
    response_class = FlaskResponse

    #: path for the static files.  If you don't want to use static files
    #: you can set this value to `None` in which case no URL rule is added
    #: and the development server will no longer serve any static files.
    static_path = '/static'

    #: if a secret key is set, cryptographic components can use this to
    #: sign cookies and other things.  Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    secret_key = None

    #: The secure cookie uses this for the name of the session cookie
    session_cookie_name = 'session'

    #: options that are passed directly to the Jinja2 environment
    jinja_options = dict(
        autoescape=True,
        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_'])

    def __init__(self, package_name):
        self.debug = False
        self.package_name = package_name
        self.view_functions = {}
        self.error_handlers = {}
        self.request_init_funcs = []
        self.request_shutdown_funcs = []
        self.url_map = Map()

        if self.static_path is not None:
            self.url_map.add(
                Rule(self.static_path + '/<filename>',
                     build_only=True,
                     endpoint='static'))

        self.jinja_env = Environment(loader=self.create_jinja_loader(),
                                     ,**self.jinja_options)
        self.jinja_env.globals.update(
            url_for=url_for,
            request=request,
            session=session,
            g=g,
            get_flashed_messages=get_flashed_messages)

    def create_jinja_loader(self):
        """Creates the Jinja loader.  By default just a package loader for
        the configured package is returned that looks up templates in the
        `templates` folder.  To add other loaders it's possible to
        override this method.
        """
        return PackageLoader(self.package_name)

    def run(self, host='localhost', port=5000, **options):
        """Runs the application on a local development server"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        if self.static_path is not None:
            options['static_files'] = {
                self.static_path: (self.package_name, 'static')
            }
            options.setdefault('use_reloader', self.debug)
            options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    @cached_property
    def test(self):
        """A test client for this application"""
        from werkzeug import Client
        return Client(self, self.response_class, use_cookies=True)

    def open_resource(self, resource):
        """Opens a resource from the application's resource folder"""
        return pkg_resources.resource_stream(self.package_name, resource)

    def open_session(self, request):
        """Creates or opens a new session.  Default implementation requires
        that `securecookie.secret_key` is set.
        """
        key = self.secret_key
        if key is not None:
            return SecureCookie.load_cookie(request,
                                            self.session_cookie_name,
                                            secret_key=key)

    def save_session(self, session, response):
        """Saves the session if it needs updates."""
        if session is not None:
            session.save_cookie(response, self.session_cookie_name)

    def route(self, rule, **options):
        """A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'
        """

        def decorator(f):
            if 'endpoint' not in options:
                options['endpoint'] = f.__name__
                self.url_map.add(Rule(rule, **options))
                self.view_functions[options['endpoint']] = f
            return f

        return decorator

    def errorhandler(self, code):
        """A decorator that is used to register a function give a given
        error code.  Example::

            @app.errorhandler(404)
            def page_not_found():
                return 'This page does not exist', 404
        """

        def decorator(f):
            self.error_handlers[code] = f
            return f

        return decorator

    def request_init(self, f):
        """Registers a function to run before each request."""
        self.request_init_funcs.append(f)
        return f

    def request_shutdown(self, f):
        """Register a function to be run after each request."""
        self.request_shutdown_funcs.append(f)
        return f

    def match_request(self):
        """Matches the current request against the URL map and also
        stores the endpoint and view arguments on the request object
        is successful, otherwise the exception is stored.
        """
        rv = _request_ctx_stack.top.url_adapter.match()
        request.endpoint, request.view_args = rv
        return rv

        """Does the request dispatching.  Matches the URL and returns the
        def dispatch_request(self):
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)

    def make_response(self, rv):
        """Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.
        """
        if isinstance(rv, self.response_class):
            return rv
        if isinstance(rv, basestring):
            return self.response_class(rv)
        if isinstance(rv, tuple):
            return self.response_class(*rv)
        return self.response_class.force_type(rv, request.environ)

    def preprocess_request(self):
        """Called before the actual request dispatching and will
        call every as :func:`request_init` decorated function.
        If any of these function returns a value it's handled as
        if it was the return value from the view and further
        request handling is stopped.
        """
        for func in self.request_init_funcs:
            rv = func()
            if rv is not None:
                return rv

    def process_response(self, response):
        """Can be overridden in order to modify the response object
        before it's sent to the WSGI server.
        """
        session = _request_ctx_stack.top.session
        if session is not None:
            self.save_session(session, response)
        for handler in self.request_shutdown_funcs:
            response = handler(response)
        return response

    def wsgi_app(self, environ, start_response):
        """The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)
        """
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
                response = self.make_response(rv)
                response = self.process_response(response)
            return response(environ, start_response)
        finally:
            _request_ctx_stack.pop()

    def __call__(self, environ, start_response):
        """Shortcut for :attr:`wsgi_app`"""
        return self.wsgi_app(environ, start_response)


# context locals
_request_ctx_stack = LocalStack()
current_app = LocalProxy(lambda: _request_ctx_stack.top.app)
request = LocalProxy(lambda: _request_ctx_stack.top.request)
session = LocalProxy(lambda: _request_ctx_stack.top.session)
g = LocalProxy(lambda: _request_ctx_stack.top.g)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#: create a new flask applications.  We pass it the name of our module
#: so that flask knows where to look for templates and static files.
app = Flask(__name__)


@app.route('/', methods=['GET'])
def index():
    """Show an overview page"""
    # return render_template('index.html')
    return "index"


@app.route('/hello/', methods=['GET', 'POST'])
def hello_user():
    """Ask the user for a name and redirect to :func:`hello`"""
    # if request.method == 'POST':
    #     return redirect(url_for('hello', name=request.form['name']))
    # return render_template('hello.html', name=None)
    return "hello"


@app.route('/hello/<name>', methods=['GET'])
def hello(name):
    """Greet name friendly"""
    # return render_template('hello.html', name=name)
    return "hello name"


# if __name__ == '__main__':
app.run(debug=True)
#+END_SRC

* 注册路由
#+BEGIN_SRC python :results valuse list :exports both
class Flask(object)
    ...
    def route(self, rule, **options):
        """A decorator that is used to register a view function for a
        given URL rule.  Example::

            @app.route('/')
            def index():
                return 'Hello World'
        """

        def decorator(f):
            if 'endpoint' not in options:
                options['endpoint'] = f.__name__
                self.url_map.add(Rule(rule, **options))
                self.view_functions[options['endpoint']] = f
            return f

        return decorator
    ...
#+END_SRC

Flask 的路由装饰器, `self.url_map.add(Rule(rule, **options))` 调用了 `Map` 类中的 `add` 方法, 其中参数 `rulefactory` 为 `Rule` 类实例.

#+BEGIN_SRC python
class Map()
    ...
    def add(self, rulefactory):
        """Add a new rule or factory to the map and bind it.  Requires that the
        rule is not bound to another map.

        :param rulefactory: a :class:`Rule` or :class:`RuleFactory`
        """
        for rule in rulefactory.get_rules(self):
            rule.bind(self)
            self._rules.append(rule)
            self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule)
        self._remap = True
    ...
#+END_SRC

`rulefactory.get_rules(self)` 只是返回 `Rule`类实例自身. 如下所示:

#+BEGIN_SRC python :results valuse list :exports both
class Rule(object)
    ...
    def get_rules(self, map):
        yield self
    ...
#+END_SRC

`self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule)`
`self._rules_by_endpoint` 初始值为 `<type 'dict'>: {'static': [<Rule '/static/<filename>' -> static>]}`.
`rule.endpoint` 即为 `Rule(string="/", methods=['GET'], endpoint="index").endpoint`, 值为 `index`.
运行后`self._rules_by_endpoint`为 `<type 'dict'>: {'index': [<Rule (unbound)>], 'static': [<Rule '/static/<filename>' -> static>]}`

* environ 参数传递
#+BEGIN_SRC python :results valuse list :exports both
class Flask(object):
    ...

    def run(self, host='localhost', port=5000, **options):
        """Runs the application on a local development server"""
        from werkzeug import run_simple
        if 'debug' in options:
            self.debug = options.pop('debug')
        if self.static_path is not None:
            options['static_files'] = {
                self.static_path: (self.package_name, 'static')
            }
            options.setdefault('use_reloader', self.debug)
            options.setdefault('use_debugger', self.debug)
        return run_simple(host, port, self, **options)

    ...
#+END_SRC

`app.run(debug=True)` 调用 werkzeug 包中的 `run_simple`, 将`app` 实例自身传入.

TODO: werkzeug 包如何将 environ 传入给 app.

* 路由响应
#+BEGIN_SRC python :results valuse list :exports both
  class Flask(object):
      ...

      def wsgi_app(self, environ, start_response):
          """The actual WSGI application.  This is not implemented in
          `__call__` so that middlewares can be applied:

              app.wsgi_app = MyMiddleware(app.wsgi_app)
          """
          _request_ctx_stack.push(_RequestContext(self, environ))
          try:
              rv = self.preprocess_request()
              if rv is None:
                  rv = self.dispatch_request()
              response = self.make_response(rv)
              response = self.process_response(response)
              return response(environ, start_response)
          finally:
              _request_ctx_stack.pop()

      ...
#+END_SRC

在 `Flask.wsgi_app` 中, `_request_ctx_stack.push(_RequestContext(self, environ))` 实例化 `_RequestContext` 类.

#+DOWNLOADED: file:///Users/c/Pictures/_request_ctx_stack.png @ 2019-06-30 16:26:02
[[file:screenshotImg/_request_ctx_stack_2019-06-30_16-26-02.png]]

#+BEGIN_SRC python :results valuse list :exports both
class _RequestContext(object):
    """The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """

    def __init__(self, app, environ):
        self.app = app
        self.url_adapter = app.url_map.bind_to_environ(environ)
        self.request = app.request_class(environ)
        self.session = app.open_session(self.request)
        self.g = _RequestGlobals()
        self.flashes = None
#+END_SRC

在该类的初始化方法中, `self.url_adapter = app.url_map.bind_to_environ(environ)` 调用 `app.url_map.bind_to_environ` 方法.
`app.url_map` 为 `Map` 类.
`Map` 类的 `bind_to_environ` 方法定义如下:

#+BEGIN_SRC python :results valuse list :exports both
class Map(object):
    ...

    def bind_to_environ(self, environ, server_name=None, subdomain=None):
        """Like :meth:`bind` but you can pass it an WSGI environment and it
        will fetch the information from that dictionary.  Note that because of
        limitations in the protocol there is no way to get the current
        subdomain and real `server_name` from the environment.  If you don't
        provide it, Werkzeug will use `SERVER_NAME` and `SERVER_PORT` (or
        `HTTP_HOST` if provided) as used `server_name` with disabled subdomain
        feature.

        If `subdomain` is `None` but an environment and a server name is
        provided it will calculate the current subdomain automatically.
        Example: `server_name` is ``'example.com'`` and the `SERVER_NAME`
        in the wsgi `environ` is ``'staging.dev.example.com'`` the calculated
        subdomain will be ``'staging.dev'``.

        If the object passed as environ has an environ attribute, the value of
        this attribute is used instead.  This allows you to pass request
        objects.  Additionally `PATH_INFO` added as a default of the
        :class:`MapAdapter` so that you don't have to pass the path info to
        the match method.

        .. versionchanged:: 0.5
            previously this method accepted a bogus `calculate_subdomain`
            parameter that did not have any effect.  It was removed because
            of that.

        :param environ: a WSGI environment.
        :param server_name: an optional server name hint (see above).
        :param subdomain: optionally the current subdomain (see above).
        """
        environ = _get_environ(environ)
        if server_name is None:
            if 'HTTP_HOST' in environ:
                server_name = environ['HTTP_HOST']
            else:
                server_name = environ['SERVER_NAME']
                if (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not \
                   in (('https', '443'), ('http', '80')):
                    server_name += ':' + environ['SERVER_PORT']
        elif subdomain is None:
            wsgi_server_name = environ.get('HTTP_HOST', environ['SERVER_NAME'])
            cur_server_name = wsgi_server_name.split(':', 1)[0].split('.')
            real_server_name = server_name.split(':', 1)[0].split('.')
            offset = -len(real_server_name)
            if cur_server_name[offset:] != real_server_name:
                raise ValueError('the server name provided (%r) does not '
                                 'match the server name from the WSGI '
                                 'environment (%r)' %
                                 (server_name, wsgi_server_name))
            subdomain = '.'.join(filter(None, cur_server_name[:offset]))
        return Map.bind(self, server_name, environ.get('SCRIPT_NAME'),
                        subdomain, environ['wsgi.url_scheme'],
                        environ['REQUEST_METHOD'], environ.get('PATH_INFO'))

    ...
#+END_SRC

`return Map.bind(self, server_name, environ.get('SCRIPT_NAME'),
                subdomain, environ['wsgi.url_scheme'],
                environ['REQUEST_METHOD'], environ.get('PATH_INFO'))`

紧接着调用 `Map` 类的 `bind` 方法.
此时的参数如下所示:
- self: Map([[<Rule '/static/<filename>' -> static>,
 <Rule '/' (HEAD, GET) -> index>,
 <Rule '/hello/' (POST, HEAD, GET) -> hello_user>,
 <Rule '/hello/<name>' (HEAD, GET) -> hello>]])

- eviron:

#+DOWNLOADED: file:///Users/c/Pictures/environ.png @ 2019-06-30 18:48:53
[[file:screenshotImg/environ_2019-06-30_18-48-53.png]]

- server_name: 'localhost:5000'

- subdomain: None

`bind` 方法定义如下:

#+BEGIN_SRC python :results valuse list :exports both
class Map(object):
    ...
    def bind(self, server_name, script_name=None, subdomain=None,
             url_scheme='http', default_method='GET', path_info=None):
        """Return a new :class:`MapAdapter` with the details specified to the
        call.  Note that `script_name` will default to ``'/'`` if not further
        specified or `None`.  The `server_name` at least is a requirement
        because the HTTP RFC requires absolute URLs for redirects and so all
        redirect exceptions raised by Werkzeug will contain the full canonical
        URL.

        If no path_info is passed to :meth:`match` it will use the default path
        info passed to bind.  While this doesn't really make sense for
        manual bind calls, it's useful if you bind a map to a WSGI
        environment which already contains the path info.

        `subdomain` will default to the `default_subdomain` for this map if
        no defined. If there is no `default_subdomain` you cannot use the
        subdomain feature.
        """
        if subdomain is None:
            subdomain = self.default_subdomain
        if script_name is None:
            script_name = '/'
        return MapAdapter(self, server_name, script_name, subdomain,
                          url_scheme, path_info, default_method)
    ...
#+END_SRC

紧接着调用 `MapAdapter` 类的初始化方法.

#+BEGIN_SRC python :results valuse list :exports both
class MapAdapter(object):
    """Returned by :meth:`Map.bind` or :meth:`Map.bind_to_environ` and does
    the URL matching and building based on runtime information.
    """

    def __init__(self, map, server_name, script_name, subdomain,
                 url_scheme, path_info, default_method):
        self.map = map
        self.server_name = server_name
        if not script_name.endswith('/'):
            script_name += '/'
        self.script_name = script_name
        self.subdomain = subdomain
        self.url_scheme = url_scheme
        self.path_info = path_info or u''
        self.default_method = default_method
#+END_SRC

此时的参数如下所示:

#+CAPTION: MapAdapter 类实例调用 match 时实例的参数

- self: <werkzeug.routing.MapAdapter object at 0x10dbc3410>

- map: Map([[<Rule '/static/<filename>' -> static>,
 <Rule '/' (HEAD, GET) -> index>,
 <Rule '/hello/' (POST, HEAD, GET) -> hello_user>,
 <Rule '/hello/<name>' (HEAD, GET) -> hello>]])

- script_name: ''

- subdomain: ''

- url_sheme: ''

- path_info: 'hello/test'

- default_method: 'GET'

<<MapAdapter 类实例调用 match 时实例的参数>>

最终返回`MapAdapter`类实例赋予变量 url_adapter.

* URL 匹配

#+BEGIN_SRC python :results valuse list :exports both
class Flask(object):
    ...
    def wsgi_app(self, environ, start_response):
        """The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied:

            app.wsgi_app = MyMiddleware(app.wsgi_app)
        """
        _request_ctx_stack.push(_RequestContext(self, environ))
        try:
            rv = self.preprocess_request()
            if rv is None:
                rv = self.dispatch_request()
                response = self.make_response(rv)
                response = self.process_response(response)
            return response(environ, start_response)
        finally:
            _request_ctx_stack.pop()
    ...
#+END_SRC

#+BEGIN_SRC python :results valuse list :exports both
class Flask(object):
    ...
    def dispatch_request(self):
        """Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.  In order to convert the return value to a
        proper response object, call :func:`make_response`.
        """
        try:
            endpoint, values = self.match_request()
            return self.view_functions[endpoint](**values)
        except HTTPException, e:
            handler = self.error_handlers.get(e.code)
            if handler is None:
                return e
            return handler(e)
        except Exception, e:
            handler = self.error_handlers.get(500)
            if self.debug or handler is None:
                raise
            return handler(e)
    ...
#+END_SRC

#+BEGIN_SRC python :results valuse list :exports both
  class Flask(object):
      ...
      def match_request(self):
          """Matches the current request against the URL map and also
          stores the endpoint and view arguments on the request object
          is successful, otherwise the exception is stored.
          """
          rv = _request_ctx_stack.top.url_adapter.match()  # _request_ctx_stack.top.url_adapter.match() => <type 'tuple'>: ('hello', {'name': u'test'})
          request.endpoint, request.view_args = rv
          return rv
      ...
#+END_SRC

`rv = _request_ctx_stack.top.url_adapter.match()` 调用 `MapAdapter` 类的 match 方法, 如下所示:
[[MapAdapter %E7%B1%BB%E5%AE%9E%E4%BE%8B%E8%B0%83%E7%94%A8 match %E6%97%B6%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%8F%82%E6%95%B0][See MapAdapter 类实例调用 match 时实例的参数]]

#+BEGIN_SRC python :results valuse list :exports both
class MapAdapter(object):
    ...

    def match(self, path_info=None, method=None, return_rule=False):
        """The usage is simple: you just pass the match method the current
        path info as well as the method (which defaults to `GET`).  The
        following things can then happen:

        - you receive a `NotFound` exception that indicates that no URL is
          matching.  A `NotFound` exception is also a WSGI application you
          can call to get a default page not found page (happens to be the
          same object as `werkzeug.exceptions.NotFound`)

        - you receive a `MethodNotAllowed` exception that indicates that there
          is a match for this URL but not for the current request method.
          This is useful for RESTful applications.

        - you receive a `RequestRedirect` exception with a `new_url`
          attribute.  This exception is used to notify you about a request
          Werkzeug requests from your WSGI application.  This is for example the
          case if you request ``/foo`` although the correct URL is ``/foo/``
          You can use the `RequestRedirect` instance as response-like object
          similar to all other subclasses of `HTTPException`.

        - you get a tuple in the form ``(endpoint, arguments)`` if there is
          a match (unless `return_rule` is True, in which case you get a tuple
          in the form ``(rule, arguments)``)

        If the path info is not passed to the match method the default path
        info of the map is used (defaults to the root URL if not defined
        explicitly).

        All of the exceptions raised are subclasses of `HTTPException` so they
        can be used as WSGI responses.  The will all render generic error or
        redirect pages.

        Here is a small example for matching:

        >>> m = Map([
        ...     Rule('/', endpoint='index'),
        ...     Rule('/downloads/', endpoint='downloads/index'),
        ...     Rule('/downloads/<int:id>', endpoint='downloads/show')
        ... ])
        >>> urls = m.bind("example.com", "/")
        >>> urls.match("/", "GET")
        ('index', {})
        >>> urls.match("/downloads/42")
        ('downloads/show', {'id': 42})

        And here is what happens on redirect and missing URLs:

        >>> urls.match("/downloads")
        Traceback (most recent call last):
          ...
        RequestRedirect: http://example.com/downloads/
        >>> urls.match("/missing")
        Traceback (most recent call last):
          ...
        NotFound: 404 Not Found

        :param path_info: the path info to use for matching.  Overrides the
                          path info specified on binding.
        :param method: the HTTP method used for matching.  Overrides the
                       method specified on binding.
        :param return_rule: return the rule that matched instead of just the
                            endpoint (defaults to `False`).

        .. versionadded:: 0.6
            `return_rule` was added.
        """
        self.map.update()
        if path_info is None:
            path_info = self.path_info
        if not isinstance(path_info, unicode):
            path_info = path_info.decode(self.map.charset, 'ignore')
            method = (method or self.default_method).upper()
            path = u'%s|/%s' % (self.subdomain, path_info.lstrip('/'))
            have_match_for = set()
        for rule in self.map._rules:
            try:
                rv = rule.match(path)
            except RequestSlash:
                raise RequestRedirect(
                    str('%s://%s%s%s/%s/' %
                        (self.url_scheme,
                         self.subdomain and self.subdomain + '.'
                         or '', self.server_name, self.script_name[:-1],
                         url_quote(path_info.lstrip('/'), self.map.charset))))
            if rv is None:
                continue
            if rule.methods is not None and method not in rule.methods:
                have_match_for.update(rule.methods)
                continue
            if self.map.redirect_defaults:
                for r in self.map._rules_by_endpoint[rule.endpoint]:
                    if r.provides_defaults_for(rule) and \
                       r.suitable_for(rv, method):
                        rv.update(r.defaults)
                        subdomain, path = r.build(rv)
                        raise RequestRedirect(
                            str('%s://%s%s%s/%s' %
                                (self.url_scheme, subdomain and subdomain + '.'
                                 or '', self.server_name,
                                 self.script_name[:-1],
                                 url_quote(path.lstrip('/'),
                                           self.map.charset))))
            if rule.redirect_to is not None:
                if isinstance(rule.redirect_to, basestring):

                    def _handle_match(match):
                        value = rv[match.group(1)]
                        return rule._converters[match.group(1)].to_url(value)

                    redirect_url = _simple_rule_re.sub(_handle_match,
                                                       rule.redirect_to)
                else:
                    redirect_url = rule.redirect_to(self, **rv)
                raise RequestRedirect(
                    str(
                        urljoin(
                            '%s://%s%s%s' %
                            (self.url_scheme,
                             self.subdomain and self.subdomain + '.'
                             or '', self.server_name, self.script_name),
                            redirect_url)))
            if return_rule:
                return rule, rv
            else:
                return rule.endpoint, rv
        if have_match_for:
            raise MethodNotAllowed(valid_methods=list(have_match_for))
        raise NotFound()

    ...
#+END_SRC

`rv = rule.match(path)` 调用 `Rule` 类的 `match` 方法, 如下所示:

#+BEGIN_SRC python :results valuse list :exports both
class Rule(RuleFactory):
    ...
    def match(self, path):
        """Check if the rule matches a given path. Path is a string in the
        form ``"subdomain|/path(method)"`` and is assembled by the map.

        If the rule matches a dict with the converted values is returned,
        otherwise the return value is `None`.

        :internal:
        """
        if not self.build_only:
            m = self._regex.search(path)
            if m is not None:
                groups = m.groupdict()
                # we have a folder like part of the url without a trailing
                # slash and strict slashes enabled. raise an exception that
                # tells the map to redirect to the same url but with a
                # trailing slash
                if self.strict_slashes and not self.is_leaf and \
                   not groups.pop('__suffix__'):
                    raise RequestSlash()
                # if we are not in strict slashes mode we have to remove
                # a __suffix__
                elif not self.strict_slashes:
                    del groups['__suffix__']

                result = {}
                for name, value in groups.iteritems():
                    try:
                        value = self._converters[name].to_python(value)
                    except ValidationError:
                        return
                    result[str(name)] = value
                if self.defaults is not None:
                    result.update(self.defaults)
                return result

    ...
#+END_SRC

此时参数如下所示:

- self: {Rule}/hello/<name>
- path: {unicode} u'|/hello/test'

`m = self._regex.search(path)` 就是用正则来匹配 URL .
`m.re.pattern` => `u'^\\|\\/hello\\/(?P<name>[^/]{1,})$'`.

#+DOWNLOADED: file:///Users/c/Pictures/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C.png @ 2019-06-30 22:20:24
[[file:screenshotImg/%25E6%25AD%25A3%25E5%2588%2599%25E5%258C%25B9%25E9%2585%258D%25E7%25BB%2593%25E6%259E%259C_2019-06-30_22-20-24.png]]
`groups = m.groupdict()` => `<type 'dict'>: {u'name': u'test'}`.

结果返回到 `MapAdapter` 类 `match` 方法中的 `rv = rule.match(path)`, `rv` 得到返回值: `<type 'tuple'>: ('hello', {'name': u'test'})`,
最终 `Flask` 类中 `match_request` 方法中的 `rv = _request_ctx_stack.top.url_adapter.match()` 得到返回值: `<type 'tuple'>: ('hello', {'name': u'test'})`.

* 请求上下文堆栈

#+BEGIN_SRC python :results valuse list :exports both
  class Flask(object):
      ...
      def wsgi_app(self, environ, start_response):
          _request_ctx_stack.push(_RequestContext(self, environ))
          ...
      ...
#+END_SRC

#+BEGIN_SRC python :results valuse list :exports both
  class LocalStack(object):
    """This class works similar to a :class:`Local` but keeps a stack
    of objects instead.  This is best explained with an example::

        >>> ls = LocalStack()
        >>> ls.push(42)
        >>> ls.top
        42
        >>> ls.push(23)
        >>> ls.top
        23
        >>> ls.pop()
        23
        >>> ls.top
        42

    They can be force released by using a :class:`LocalManager` or with
    the :func:`release_local` function but the correct way is to pop the
    item from the stack after using.  When the stack is empty it will
    no longer be bound to the current context (and as such released).

    By calling the stack without arguments it returns a proxy that resolves to
    the topmost item on the stack.

    .. versionadded:: 0.6.1
    """

    def __init__(self):
        self._local = Local()
        self._lock = allocate_lock()

    def __release_local__(self):
        self._local.__release_local__()

    def __call__(self):
        def _lookup():
            rv = self.top
            if rv is None:
                raise RuntimeError('object unbound')
            return rv
        return LocalProxy(_lookup)

    def push(self, obj):
        """Pushes a new item to the stack"""
        self._lock.acquire()
        try:
            rv = getattr(self._local, 'stack', None)
            if rv is None:
                self._local.stack = rv = []
            rv.append(obj)
            return rv
        finally:
            self._lock.release()

    def pop(self):
        """Removes the topmost item from the stack, will return the
        old value or `None` if the stack was already empty.
        """
        self._lock.acquire()
        try:
            stack = getattr(self._local, 'stack', None)
            if stack is None:
                return None
            elif len(stack) == 1:
                release_local(self._local)
                return stack[-1]
            else:
                return stack.pop()
        finally:
            self._lock.release()

    @property
    def top(self):
        """The topmost item on the stack.  If the stack is empty,
        `None` is returned.
        """
        try:
            return self._local.stack[-1]
        except (AttributeError, IndexError):
            return None

#+END_SRC

调用 `LocalStack` 的 `push` 方法.
第一入栈时代理访问到 self._local 的 stack 值为空, 即 `rv` 值为 None.

#+DOWNLOADED: file:///Users/c/Pictures/%E7%AC%AC%E4%B8%80%E5%85%A5%E6%A0%88%E6%97%B6%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE%E5%88%B0self._local%E7%9A%84stack%E5%80%BC%E4%B8%BA%E7%A9%BA.png @ 2019-06-30 20:20:13
[[file:screenshotImg/%25E7%25AC%25AC%25E4%25B8%2580%25E5%2585%25A5%25E6%25A0%2588%25E6%2597%25B6%25E4%25BB%25A3%25E7%2590%2586%25E8%25AE%25BF%25E9%2597%25AE%25E5%2588%25B0self._local%25E7%259A%2584stack%25E5%2580%25BC%25E4%25B8%25BA%25E7%25A9%25BA_2019-06-30_20-20-13.png]]
此时参数如下所示:
- obj:

#+DOWNLOADED: file:///Users/c/Pictures/obj.png @ 2019-06-30 20:22:44
[[file:screenshotImg/obj_2019-06-30_20-22-44.png]]

`rv = getattr(self._local, 'stack', None)` 调用 `Local` 类中 `__setattr__` 方法.

#+BEGIN_SRC python :results valuse list :exports both
class Local(object):
    __slots__ = ('__storage__', '__lock__')

    def __init__(self):
        object.__setattr__(self, '__storage__', {})
        object.__setattr__(self, '__lock__', allocate_lock())

    def __iter__(self):
        return self.__storage__.iteritems()

    def __call__(self, proxy):
        """Create a proxy for a name."""
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(get_ident(), None)

    def __getattr__(self, name):
        self.__lock__.acquire()
        try:
            try:
                return self.__storage__[get_ident()][name]
            except KeyError:
                raise AttributeError(name)
        finally:
            self.__lock__.release()

    def __setattr__(self, name, value):
        self.__lock__.acquire()
        try:
            ident = get_ident()
            storage = self.__storage__
            if ident in storage:
                storage[ident][name] = value
            else:
                storage[ident] = {name: value}
        finally:
            self.__lock__.release()

    def __delattr__(self, name):
        self.__lock__.acquire()
        try:
            try:
                del self.__storage__[get_ident()][name]
            except KeyError:
                raise AttributeError(name)
        finally:
            self.__lock__.release()
#+END_SRC

#+DOWNLOADED: file:///Users/c/Pictures/%E5%85%A5%E6%A0%88%E5%90%8E.png @ 2019-06-30 20:24:43
[[file:screenshotImg/%25E5%2585%25A5%25E6%25A0%2588%25E5%2590%258E_2019-06-30_20-24-43.png]]
